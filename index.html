<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Berlinale Alien Walk</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
  #instructions {
    position: absolute;
    top: 40%;
    width: 100%;
    text-align: center;
    color: white;
    font-family: sans-serif;
    font-size: 24px;
  }
</style>
</head>
<body>
<div id="instructions">Click to start FPS controls</div>

<script type="module">
import * as THREE from 'https://esm.sh/three@0.160.0';
import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
import SimplexNoise from 'https://esm.sh/simplex-noise@3.0.0';


// --- Scene, Camera, Renderer ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,2,5);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Lights ---
scene.add(new THREE.AmbientLight(0xffffff, 2));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(10,20,10);
scene.add(dirLight);

// --- Floor ---
const floorGeo = new THREE.PlaneGeometry(200,200);
const floorMat = new THREE.MeshStandardMaterial({color:0x222222});
const floor = new THREE.Mesh(floorGeo,floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

/* ---------- TERRAIN  ---------- */

/* ---------- ALIEN TERRAIN ---------- */

const simplex = new SimplexNoise();

const terrainSize = 300;
const terrainSegments = 128;
const terrainFreq = 0.05;  // higher frequency → more chaotic
const terrainAmp = 18.0;   // much taller spikes

// Geometry
const terrainGeo = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
terrainGeo.rotateX(-Math.PI / 2);

// Make terrain spiky & alien
const pos = terrainGeo.attributes.position;
for (let i = 0; i < pos.count; i++) {
  const x = pos.getX(i);
  const z = pos.getZ(i);

  // Layered noise → spiky fractal feel
  let y = 0;
  let amp = terrainAmp;
  let freq = terrainFreq;
  for (let o = 0; o < 4; o++) {
    y += Math.abs(simplex.noise2D(x * freq, z * freq)) * amp;
    freq *= 2.0;
    amp *= 0.5;
  }

  pos.setY(i, y);
}
terrainGeo.computeVertexNormals();

/* ---------- Alien Shader Material ---------- */
const alienMat = new THREE.ShaderMaterial({
  uniforms: {
    time: { value: 0.0 }
  },
  vertexShader: `
    varying vec3 vNormal;
    varying vec3 vPos;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float time;
    varying vec3 vNormal;
    varying vec3 vPos;

    void main() {
      // Iridescent alien colors based on position + time
      float intensity = abs(sin(time*0.5 + vPos.x*0.05 + vPos.z*0.05));
      vec3 baseColor = vec3(
        0.5 + 0.5*sin(vPos.x*0.1 + time),
        0.5 + 0.5*sin(vPos.z*0.1 + time*1.2),
        0.5 + 0.5*sin((vPos.x+vPos.z)*0.1 - time*0.8)
      );

      // Add spiky highlight based on normal
      float highlight = pow(max(dot(vNormal, vec3(0.2,1.0,0.3)), 0.0), 2.0);
      vec3 color = mix(baseColor, vec3(1.0,0.2,1.0), highlight * intensity);

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide
});

const terrainMesh = new THREE.Mesh(terrainGeo, alienMat);
scene.add(terrainMesh);

/* ---------- Fog for atmosphere ---------- */
scene.fog = new THREE.FogExp2(0x000000, 0.005);

/* ---------- Animate alien shimmer ---------- */
function updateTerrainShader(delta) {
  alienMat.uniforms.time.value += delta;
}

// --- FPS Pointer Lock Controls ---
let move = {forward:false, backward:false, left:false, right:false};
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let pitch = 0, yaw = 0;
let pointerLocked = false;

document.getElementById('instructions').addEventListener('click', () => {
    document.body.requestPointerLock();
});

document.addEventListener('pointerlockchange', () => {
    pointerLocked = document.pointerLockElement === document.body;
    document.getElementById('instructions').style.display = pointerLocked ? 'none' : 'block';
});

document.addEventListener('mousemove', (e) => {
    if (!pointerLocked) return;
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    camera.rotation.set(pitch, yaw, 0);
});

document.addEventListener('keydown', e => {
    if (e.code==='KeyW') move.forward=true;
    if (e.code==='KeyS') move.backward=true;
    if (e.code==='KeyA') move.left=true;
    if (e.code==='KeyD') move.right=true;
});
document.addEventListener('keyup', e => {
    if (e.code==='KeyW') move.forward=false;
    if (e.code==='KeyS') move.backward=false;
    if (e.code==='KeyA') move.left=false;
    if (e.code==='KeyD') move.right=false;
});


// --- GLTFLoader with DRACOLoader ---
const loader = new GLTFLoader();
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
loader.setDRACOLoader(dracoLoader);

loader.load(
    './models/rigid_astronaut.glb',
    gltf => {
        const model = gltf.scene;
        model.position.set(0,1,0);
        model.rotation.y = Math.PI; // rotate if needed
        model.scale.set(2,2,2); // adjust to fit camera view
    model.position.y = 4;
        scene.add(model);
// --- Set initial yaw so camera faces astronaut ---
        const dx = model.position.x - camera.position.x;
        const dz = model.position.z - camera.position.z;
        yaw = Math.atan2(dx, dz); // rotate horizontally toward astronaut
        pitch = 0; // optional: keep level
        camera.rotation.set(pitch, yaw, 0);
    },

    xhr => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
    error => console.error(error)
);

// --- Animation Loop ---
const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    // Smooth movement damping
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;

    // Direction
    direction.z = Number(move.forward) - Number(move.backward);
    direction.x = Number(move.right) - Number(move.left);
    direction.normalize();

    if (move.forward || move.backward) velocity.z -= direction.z * 50.0 * delta;
    if (move.left || move.right) velocity.x -= direction.x * 50.0 * delta;

    // Apply movement relative to camera yaw
    const forward = new THREE.Vector3(Math.sin(yaw),0,-Math.cos(yaw));
    const right = new THREE.Vector3(Math.cos(yaw),0,Math.sin(yaw));
    camera.position.addScaledVector(forward, velocity.z * delta);
    camera.position.addScaledVector(right, velocity.x * delta);

    renderer.render(scene,camera);
}
animate();

// --- Handle Window Resize ---
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
